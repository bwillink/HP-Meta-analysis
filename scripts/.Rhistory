level = 2, fitfunction = rma.glmulti, crit="aicc")
# Variable importance plot across all the models
plot(res, type="s")
weightable(res)
# First, we evaluate some code that generates helper functions needed so that metafor and MuMIn could interact as necessary
eval(metafor:::.MuMIn)
# Now, we take the full model (in this case Q2m4) and fit the rest of the models and examine those models whose AICc value is no more than 2 units away from that of the best model
full_model <- rma.mv(
g,
V = varcovmat_2_PD$mat,
mods = ~ Trait.type * Gradient.category,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_2,
method = "ML"
)
# Fit all models
res <- glmulti(g ~ Trait.type*Gradient.category,
data=dat_2,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
level = 2, fitfunction = rma.glmulti, crit="aicc")
weightable(res)
model_selection <- dredge(full_model, trace = 2)
model_selection
full_model
weightable(res)
subset(model_selection, delta <= 2, recalc.weights = FALSE)
?dredge
weightable(res)
# relative importance values for the predictors can be obtained with:
importance(model_selection)
# Multimodel inference
average.model <- model.avg(model_selection, revised.var=FALSE)
summary(average.model) #Set revised.var = F to get same results as we would with the glmulti package
model_selection <- dredge(full_model, trace = 2)
subset(model_selection, delta <= 10, recalc.weights = FALSE)
subset(model_selection, recalc.weights = FALSE)
model_selection
res
full_model
# Organized table, getting the unconditional estimates
mmi <- as.data.frame(coef(res))
mmi$z <- mmi$Estimate / mmi$SE
mmi$p <- 2*pnorm(abs(mmi$z), lower.tail=FALSE)
names(mmi) <- c("Estimate", "Std. Error", "Importance", "z value", "Pr(>|z|)")
mmi$ci.lb <- mmi[[1]] - qnorm(.975) * mmi[[2]]
mmi$ci.ub <- mmi[[1]] + qnorm(.975) * mmi[[2]]
#To get the glmulti package to handle rma.uni objects, we must register a getfit method for such objects
eval(metafor:::.glmulti)
coef(res)
# Organized table, getting the unconditional estimates
mmi <- as.data.frame(coef(res))
mmi <- data.frame(Estimate=mmi$Est, SE=sqrt(mmi$Uncond), Importance=mmi$Importance, row.names=row.names(mmi))
mmi$z <- mmi$Estimate / mmi$SE
mmi$p <- 2*pnorm(abs(mmi$z), lower.tail=FALSE)
names(mmi) <- c("Estimate", "Std. Error", "Importance", "z value", "Pr(>|z|)")
mmi$ci.lb <- mmi[[1]] - qnorm(.975) * mmi[[2]]
mmi$ci.ub <- mmi[[1]] + qnorm(.975) * mmi[[2]]
mmi <- mmi[order(mmi$Importance, decreasing=TRUE), c(1,2,4:7,3)]
round(mmi, 4)
x <- c("Gradient.category" == "Environment", "Trait.type" == "Intensity")
preds <- list()
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
yhat <- sum(weights * sapply(preds, function(x) x$pred))
round(yhat, 3)
se <- sqrt(sum(weights * sapply(preds, function(x) x$se^2 + (x$pred - yhat)^2)))
round(yhat + c(-1,1)*qnorm(.975)*se, 3)
weights <- weightable(res)$weights
weights
?coef.glmulti
coef.glmulti(res, varweighting = "Buckland", icmethod = "Standard", se.fit = TRUE)
round(mmi, 4)
predict(res, varweighting = "Buckland", icmethod = "Standard", se.fit = TRUE)
warnings(predict(res, varweighting = "Buckland", icmethod = "Standard", se.fit = TRUE))
?predict.glmulti
predict.glmulti(res, varweighting = "Buckland", icmethod = "Standard", se.fit = TRUE)
x
x <- c("Gradient.category" == "Environment", "Trait.type" == "Intensity")
x
x <- c("length"=15, "wic"=1, "feedback"=1, "info"=0, "pers"=0, "imag"=1, "meta"=1)
x
x <- data.frame("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
x
preds <- list()
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
# Fit all models
res <- glmulti(g ~ Trait.type*Gradient.category,
data=dat_2,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
level = 2, fitfunction = rma.glmulti, crit="aicc")
coef(res)
# Organized table, getting the unconditional estimates
mmi <- as.data.frame(coef(res))
mmi <- data.frame(Estimate=mmi$Est, SE=sqrt(mmi$Uncond), Importance=mmi$Importance, row.names=row.names(mmi))
mmi$z <- mmi$Estimate / mmi$SE
mmi$p <- 2*pnorm(abs(mmi$z), lower.tail=FALSE)
names(mmi) <- c("Estimate", "Std. Error", "Importance", "z value", "Pr(>|z|)")
mmi$ci.lb <- mmi[[1]] - qnorm(.975) * mmi[[2]]
mmi$ci.ub <- mmi[[1]] + qnorm(.975) * mmi[[2]]
mmi <- mmi[order(mmi$Importance, decreasing=TRUE), c(1,2,4:7,3)]
round(mmi, 4)
x <- data.frame("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
preds <- list()
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
x <- "Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence")
x <- c("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
x
preds <- list()
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
names(coef(model))
# Fit all models
res <- glmulti(g ~ Trait.type:Gradient.category,
data=dat_2,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
level = 2, fitfunction = rma.glmulti, crit="aicc")
coef(res)
# Organized table, getting the unconditional estimates
mmi <- as.data.frame(coef(res))
mmi <- data.frame(Estimate=mmi$Est, SE=sqrt(mmi$Uncond), Importance=mmi$Importance, row.names=row.names(mmi))
mmi$z <- mmi$Estimate / mmi$SE
mmi$p <- 2*pnorm(abs(mmi$z), lower.tail=FALSE)
names(mmi) <- c("Estimate", "Std. Error", "Importance", "z value", "Pr(>|z|)")
mmi$ci.lb <- mmi[[1]] - qnorm(.975) * mmi[[2]]
mmi$ci.ub <- mmi[[1]] + qnorm(.975) * mmi[[2]]
mmi <- mmi[order(mmi$Importance, decreasing=TRUE), c(1,2,4:7,3)]
round(mmi, 4)
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
x <- data.frame("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
names(coef(model))
x <- c("length"=15, "wic"=1, "feedback"=1, "info"=0, "pers"=0, "imag"=1, "meta"=1)
x
x <- data.frame("Gradient.category" = "Environment", "Trait.type" = "Intensity")
x
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
x <- data.frame("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
x
subset(model_selection, delta <= 10, recalc.weights = FALSE)
weightable(res)
top
# Fit all models
res <- glmulti(g ~ Trait.type*Gradient.category,
data=dat_2,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
level = 2, fitfunction = rma.glmulti, crit="aicc")
# Top models
top <- weightable(res)
top
coef(res)
# Organized table, getting the unconditional estimates
mmi <- as.data.frame(coef(res))
mmi <- data.frame(Estimate=mmi$Est, SE=sqrt(mmi$Uncond), Importance=mmi$Importance, row.names=row.names(mmi))
mmi$z <- mmi$Estimate / mmi$SE
mmi$p <- 2*pnorm(abs(mmi$z), lower.tail=FALSE)
names(mmi) <- c("Estimate", "Std. Error", "Importance", "z value", "Pr(>|z|)")
mmi$ci.lb <- mmi[[1]] - qnorm(.975) * mmi[[2]]
mmi$ci.ub <- mmi[[1]] + qnorm(.975) * mmi[[2]]
mmi <- mmi[order(mmi$Importance, decreasing=TRUE), c(1,2,4:7,3)]
round(mmi, 4)
round(mmi, 4)
model_selection
# Multimodel inference
average.model <- model.avg(model_selection, revised.var=FALSE)
summary(average.model) #Set revised.var = F to get same results as we would with the glmulti package
Q1m1 <-
rma.mv(
g ~ 1,
V = varcovmat_1_PD$mat,
random = list(  ~ 1 |Experiment/ID, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m1)
Q1m2 <-
rma.mv(
g ~ Trait.category:Trait.type -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | as.factor(ID), ~ 1 | as.factor(Experiment), ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m2)
forest.default(x= Q1m2$beta, sei =  Q1m2$se, ci.lb =  Q1m2$ci.lb, ci.ub =  Q1m2$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Infected fecundity", "Uninfected fecundity",
"Infected survivorship", "Uninfected survivorship"))
Q1m3 <-
rma.mv(
g ~ Trait.category : Trait.type : Gradient.category -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment/ID, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m3)
forest.default(x= Q1m3$beta, sei =  Q1m3$se, ci.lb =  Q1m3$ci.lb, ci.ub =  Q1m3$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment infected fecundity", "Environment uninfected fecundity", "Environment infected survivorship", "Environment uninfected survivorship", "Pollution infected fecundity", "Pollution uninfected fecundity", "Pollution infected survivorship", "Pollution uninfected survivorship", "Resource infected fecundity", "Resource uninfected fecundity", "Resource infected survivorship", "Resource uninfected survivorship"))
Q1m4 <-
rma.mv(
g ~ Trait.type:Gradient.category -1 ,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment/ID, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m4)
forest.default(x= Q1m4$beta, sei =  Q1m4$se, ci.lb =  Q1m4$ci.lb, ci.ub =  Q1m4$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment fecundity", "Environment survivorship", "Pollution  fecundity", "Pollution  survivorship", "Resource  fecundity", "Resource  survivorship"))
Q1m5 <-
rma.mv(
g ~ Trait.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m5)
forest.default(x= Q1m5$beta, sei =  Q1m5$se, ci.lb =  Q1m5$ci.lb, ci.ub =  Q1m5$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Invertebrate infected", "Invertebrate uninfected", "Vertebrate infected", "Vertebrate  uninfected"))
Q1m5 <-
rma.mv(
g ~ Trait.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m5)
forest.default(x= Q1m5$beta, sei =  Q1m5$se, ci.lb =  Q1m5$ci.lb, ci.ub =  Q1m5$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Invertebrate infected", "Invertebrate uninfected", "Vertebrate infected", "Vertebrate  uninfected"))
Q1m6 <-
rma.mv(
g ~ Trait.category:Gradient.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m6)
forest.default(x= Q1m6$beta, sei =  Q1m6$se, ci.lb =  Q1m6$ci.lb, ci.ub =  Q1m6$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment invertebrate infected", "Environment invertebrate uninfected", "Pollution invertebrate infected", "Pollution invertebrate uninfected", "Resource invertebrate infected", "Resource invertebrate uninfected", "Environment vertebrate infected", "Environment vertebrate uninfected", "Pollution vertebrate infected", "Pollution vertebrate uninfected", "Resource vertebrate infected", "Resource vertebrate uninfected"))
Q1m6 <-
rma.mv(
g ~ Trait.category:Gradient.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m6)
forest.default(x= Q1m6$beta, sei =  Q1m6$se, ci.lb =  Q1m6$ci.lb, ci.ub =  Q1m6$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment invertebrate infected", "Environment invertebrate uninfected", "Pollution invertebrate infected", "Pollution invertebrate uninfected", "Resource invertebrate infected", "Resource invertebrate uninfected", "Environment vertebrate infected", "Environment vertebrate uninfected", "Pollution vertebrate infected", "Pollution vertebrate uninfected", "Resource vertebrate infected", "Resource vertebrate uninfected"))
Q1m7 <-
rma.mv(
g ~ Trait.type:Gradient.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m7)
forest.default(x= Q1m7$beta, sei =  Q1m7$se, ci.lb =  Q1m7$ci.lb, ci.ub =  Q1m7$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment invertebrate fecundity", "Environment invertebrate survivorship", "Pollution invertebrate fecundity", "Pollution invertebrate survivorship", "Resource invertebrate fecundity", "Resource invertebrate survivorship", "Environment vertebrate survivorship", "Pollution vertebrate survivorship", "Resource vertebrate survivorship"))
Q1m8 <-
rma.mv(
g ~ Gradient.category:Host.type.2 -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1m8)
forest.default(x= Q1m8$beta, sei =  Q1m8$se, ci.lb =  Q1m8$ci.lb, ci.ub =  Q1m8$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment invertebrate", "Pollution invertebrate", "Resource invertebrate", "Environment vertebrate", "Pollution vertebrate", "Resource vertebrate "))
?predict.glmulti
?predict.glmulti
x <- data.frame("Gradient.category" = c("Environment", "Pollution", "Resource", "Environment", "Pollution", "Resource"), "Trait.type" = c("Intensity", "Intensity", "Intensity", "Prevalence", "Prevalence", "Prevalence"))
predict.glmulti(res, varweighting = "Buckland", newdata = NA, icmethod = "Lukacs", se.fit = TRUE)
predict.glmulti(res, varweighting = "Buckland", newdata = x, icmethod = "Lukacs", se.fit = TRUE)
x <- c("length"=15, "wic"=1, "feedback"=1, "info"=0, "pers"=0, "imag"=1, "meta"=1)
x
x <- c("Gradient.category" = "Environment", "Trait.type" = "Intensity")
x
data.frame
x <- data.frame("Gradient.category" = "Environment", "Trait.type" = "Intensity")
x
x <- c("Gradient.category" = "Environment", "Trait.type" = "Intensity")
x
x <- c("length"=15, "wic"=1, "feedback"=1, "info"=0, "pers"=0, "imag"=1, "meta"=1)
x
x <- c("Gradient.category" = "Environment", "Trait.type" = "Intensity")
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
res@objects
names(coef(model))
names(coef(model))[-1]
dat.test <- dat.bangertdrowns2004
dat.test <- dat.test[!apply(dat.test[,c("length", "wic", "feedback", "info", "pers", "imag", "meta")], 1, anyNA),]
rma.glmulti <- function(formula, data, ...){
rma(formula, vi, data=data, method="ML", ...)
}
res <- glmulti(yi ~ length + wic + feedback + info + pers + imag + meta, data=dat,
level=1, fitfunction=rma.glmulti, crit="aicc", confsetsize=128)
View(dat.test)
View(dat.test)
rma.glmulti <- function(formula, data, ...)
rma(formula, vi, data=data, method="ML", ...)
res <- glmulti(yi ~ length + wic + feedback + info + pers + imag + meta, data=dat,
level=1, fitfunction=rma.glmulti, crit="aicc", confsetsize=128)
res <- glmulti(yi ~ length + wic + feedback + info + pers + imag + meta, data=dat.test,
level=1, fitfunction=rma.glmulti, crit="aicc", confsetsize=128)
coef(res)
x <- c("length"=15, "wic"=1, "feedback"=1, "info"=0, "pers"=0, "imag"=1, "meta"=1)
x
names(coef(model))
preds <- list()
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
names(coef(model))
weightable(res)
# Define a function that takes a model formula and a dataset as input and then fits a random/mixed-effects meta-regression model to the given data using maximum likelihood estimation (o compare models, we have to use ML)
rma.glmulti <- function(formula, data, V, random, ...){
rma.mv(formula, V = V, data = data, random = random, method="ML", ...)
}
# Fit all models
res <- glmulti(g ~ Trait.type*Gradient.category,
data=dat_2,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
level = 2, fitfunction = rma.glmulti, crit="aicc")
weightable(res)
weightable(res)
coef(res)
x <- c("Gradient.category" = "Environment", "Trait.type" = "Intensity", "Gradient.category:Trait.type" = "Environment:Intensity")
x
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
names(coef(model))
x <- c("Gradient.categoryPollution" = T, "Gradient.categoryEnvironment" = F, "Gradient.categoryResource" = F, "Trait.typeIntensity" = T, "Trait.typePrevalence" = F, "Gradient.categoryEnvironment:Trait.typeIntensity" = F, "Gradient.categoryPollution:Trait.typeIntensity" = F, "Gradient.categoryResource:Trait.typeIntensity" = F, "Gradient.categoryEnvironment:Trait.typePrevalence" = F, "Gradient.categoryResource:Trait.typePrevalence" = F, "Gradient.categoryPollution:Trait.typePrevalence" = F)
x
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
x <- c("Gradient.categoryPollution" = T, "Gradient.categoryResource" = F, "Trait.typePrevalence" = T, "Gradient.categoryEnvironment:Trait.typeIntensity" = F, "Gradient.categoryPollution:Trait.typeIntensity" = F, "Gradient.categoryResource:Trait.typeIntensity" = F, "Gradient.categoryEnvironment:Trait.typePrevalence" = F, "Gradient.categoryResource:Trait.typePrevalence" = F, "Gradient.categoryPollution:Trait.typePrevalence" = F)
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
x
x[vars]
names(coef(model))
x <- c("Gradient.categoryPollution" = T, "Gradient.categoryResource" = F, "Trait.typePrevalence" = T, "Gradient.categoryEnvironment:Trait.typeIntensity" = F, "Gradient.categoryPollution:Trait.typeIntensity" = F, "Gradient.categoryResource:Trait.typeIntensity" = F, "Gradient.categoryEnvironment:Trait.typePrevalence" = F, "Trait.typePrevalence:Gradient.categoryResource" = F, "Trait.typePrevalence:Gradient.categoryPollution" = F)
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
names(coef(model))
x[vars]
x <- c("Gradient.categoryPollution" = T, "Gradient.categoryResource" = F, "Trait.typePrevalence" = T, "Gradient.categoryEnvironment:Trait.typeIntensity" = F, "Gradient.categoryPollution:Trait.typeIntensity" = F,
"Gradient.categoryResource:Trait.typeIntensity" = F, "Gradient.categoryEnvironment:Trait.typePrevalence" = F,
"Gradient.categoryPollution:Trait.typePrevalence" = F,
"Gradient.categoryResource:Trait.typePrevalence" = F,
"Trait.typePrevalence:Gradient.categoryResource" = F,
"Trait.typePrevalence:Gradient.categoryPollution" = F,
"Trait.typePrevalence:Gradient.categoryEnvironment" = F,
"Trait.typeIntensity:Gradient.categoryResource" = F,
"Trait.typeIntensity:Gradient.categoryPollution" = F,
"Trait.typeIntensity:Gradient.categoryEnvironment" = F)
for (j in 1:res@nbmods) {
model <- res@objects[[j]]
vars <- names(coef(model))[-1]
if (length(vars) == 0) {
preds[[j]] <- predict(model)
} else {
preds[[j]] <- predict(model, newmods=x[vars])
}
}
weights <- weightable(res)$weights
yhat <- sum(weights * sapply(preds, function(x) x$pred))
round(yhat, 3)
se <- sqrt(sum(weights * sapply(preds, function(x) x$se^2 + (x$pred - yhat)^2)))
round(yhat + c(-1,1)*qnorm(.975)*se, 3)
x
data.frame(x)
# Now, we take the full model (in this case Q2m4) and fit the rest of the models and examine those models whose AICc value is no more than 2 units away from that of the best model
full_model <- rma.mv(
g,
V = varcovmat_2_PD$mat,
mods = ~ Trait.type * Gradient.category,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_2,
method = "ML"
)
model_selection <- dredge(full_model, trace = 2)
?model.avg
# Multimodel inference
average.model <- model.avg(model_selection, revised.var=FALSE, fit = T)
# Multimodel inference
average.model <- model.avg(model_selection, revised.var=FALSE)
summary(average.model) #Set revised.var = F to get same results as we would with the glmulti package
#How do we get model predictions?
predict(average.model, newdata = data.frame(x), se.fit = T)
predict(average.model, newdata = data.frame(c("Gradient.categoryPollution" = T, "Gradient.categoryResource" = F, "Trait.typePrevalence" = T, "Gradient.categoryPollution:Trait.typePrevalence" = F,
"Gradient.categoryResource:Trait.typePrevalence" = F)), se.fit = T)
?predict.averaging
#How do we get model predictions?
predict(average.model, se.fit = T)
average.model
