"Number of prevalence effects",
"Number of intensity effects",
"Number of fitness effects",
"Number of survival effects",
"Number of fecundity effects"
),
Question_1 = c(
length(unique(dat_1$Study)),
length(dat_1$g),
length(unique(dat_1$Experiment)),
length(unique(dat_1$Host[which(dat_1$Host.type == "Arthropod")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Mollusc")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Fish")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Amphibian")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Reptile")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Bird")])),
length(unique(dat_1$Host[which(dat_1$Host.type == "Mammal")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Virus")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Bacteria")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Multiple")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Fungus")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Protozoan")])),
length(unique(dat_1$Parasite[which(dat_1$Parasite.type ==
"Helminth")])),
length(dat_1$Experiment[which(dat_1$Gradient.category ==
"Environment")]),
length(dat_1$Experiment[which(dat_1$Gradient.category ==
"Pollution")]),
length(dat_1$Experiment[which(dat_1$Gradient.category ==
"Resource")]),
length(dat_1$ID[which(dat_1$Trait.category == "Epidemiological")]),
length(dat_1$ID[which(dat_1$Trait.type == "Prevalence")]),
length(dat_1$ID[which(dat_1$Trait.type == "Intensity")]),
length(dat_1$ID[grep("demographic", dat_1$Trait.category)]),
length(dat_1$ID[which(dat_1$Trait.type == "Survivorship")]),
length(dat_1$ID[which(dat_1$Trait.type == "Fecundity")])
),
Question_2 = c(
length(unique(dat_2$Study)),
length(dat_2$g),
length(unique(dat_2$Experiment)),
length(unique(dat_2$Host[which(dat_2$Host.type == "Arthropod")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Mollusc")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Fish")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Amphibian")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Reptile")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Bird")])),
length(unique(dat_2$Host[which(dat_2$Host.type == "Mammal")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Virus")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Bacteria")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Multiple")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Fungus")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Protozoan")])),
length(unique(dat_2$Parasite[which(dat_2$Parasite.type ==
"Helminth")])),
length(dat_2$Experiment[which(dat_2$Gradient.category ==
"Environment")]),
length(dat_2$Experiment[which(dat_2$Gradient.category ==
"Pollution")]),
length(dat_2$Experiment[which(dat_2$Gradient.category ==
"Resource")]),
length(dat_2$ID[which(dat_2$Trait.category == "Epidemiological")]),
length(dat_2$ID[which(dat_2$Trait.type == "Prevalence")]),
length(dat_2$ID[which(dat_2$Trait.type == "Intensity")]),
length(dat_2$ID[grep("demographic", dat_2$Trait.category)]),
length(dat_2$ID[which(dat_2$Trait.type == "Survivorship")]),
length(dat_2$ID[which(dat_2$Trait.type == "Fecundity")])
)
)
d_stats %>%
kbl() %>%
kable_material(c("striped", "hover"), full_width = F)
# First, we evaluate some code that generates helper functions needed so that metafor and MuMIn could interact as necessary
eval(metafor:::.MuMIn)
# Now, we take the full model and fit the rest of the models and examine those models whose AICc value is no more than 10 units away from that of the best model
full_model.1 <- rma.mv(
g,
V = varcovmat_1_PD$mat,
mods = ~ Trait.category*Trait.type*Gradient.category,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_1,
method = "ML"
)
model_selection.1 <- dredge(full_model.1, trace = 2)
subset(model_selection.1, delta <= 10, recalc.weights = FALSE)
# relative importance values for the predictors can be obtained with:
importance(model_selection.1)
Q1 <-
rma.mv(
g ~ Trait.type:Gradient.category -1 ,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment/ID, ~ 1 | Parasite),
data = dat_1,
method = "REML"
)
summary(Q1)
forest.default(x= Q1$beta, sei =  Q1$se, ci.lb =  Q1$ci.lb, ci.ub =  Q1$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment fecundity", "Environment survivorship", "Pollution  fecundity", "Pollution  survivorship", "Resource  fecundity", "Resource  survivorship"))
full_model.2 <- rma.mv(
g,
V = varcovmat_2_PD$mat,
mods = ~ Trait.type*Gradient.category,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_2,
method = "ML"
)
# Define if using Trait.type or Trait.category
model_selection.2 <- dredge(full_model.2, trace = 2)
subset(model_selection.2, delta <= 10, recalc.weights = FALSE)
# relative importance values for the predictors can be obtained with:
importance(model_selection.2)
full_model.2.merged <- rma.mv(
g,
V = varcovmat_2_PD$mat,
mods = ~ Trait.type*Gradient.category.2,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_2,
method = "ML"
)
# Define if using Trait.type or Trait.category
model_selection.2.merged <- dredge(full_model.2.merged, trace = 2)
subset(model_selection.2.merged, delta <= 10, recalc.weights = FALSE)
# relative importance values for the predictors can be obtained with:
importance(model_selection.2.merged)
full_model.2.rvf <- rma.mv(
g,
V = varcovmat_2_PD$mat,
mods = ~ Trait.category*Gradient.category,
random = list( ~ 1 | ID, ~ 1 | Experiment, ~ 1 | Parasite),
data = dat_2,
method = "ML"
)
# Define if using Trait.type or Trait.category
model_selection.2.rvf <- dredge(full_model.2.rvf, trace = 2)
subset(model_selection.2.rvf, delta <= 10, recalc.weights = FALSE)
# relative importance values for the predictors can be obtained with:
importance(model_selection.2.rvf)
Q2 <-
rma.mv(
g ~ Trait.type:Gradient.category -1,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | Experiment/ID, ~ 1 | Parasite),
data = dat_2,
method = "REML",
)
summary(Q2)
forest.default(x= Q2$beta, sei =  Q2$se, ci.lb =  Q2$ci.lb, ci.ub =  Q2$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("Environment fecundity", "Environment intensity", "Environment prevalence", "Environment survivorship", "Pollution fecundity", "Pollution intensity", "Pollution prevalence", "Pollution survivorship", "Resource fecundity", "Resource intensity", "Resource prevalence", "Resource survivorship"))
# re fit as a mixed effects model with rma.uni
# any fitting method other than "FE" works for a random/mixed effects model
Q1.uni <-
rma.uni(
g ~ Trait.type:Gradient.category + Experiment + ID ,
vi = dat_1$var.g,
data = dat_1,
method = "REML"
)
# get conditional residuals (residuals for each effect)
Q1res <- rstandard.rma.uni(Q1.uni, type = "conditional")
# create colour palette as  gradient of effect size g
nlvl <- length(dat_1$g)
pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))(nlvl)
pal <-pal[order(match(pal,dat_1$g))]
# plot funnel with conditional residuals
metafor::funnel(Q1res$resid, sqrt(dat_1$var.g), level=c(90, 95, 99), shade=c("white", "gray55", "gray75"), col=pal, back = "white", refline=0, legend=TRUE, xlab = "Conditional residual", ylab = "Standard error")
View(dat)
# re fit as a mixed effects model with rma.uni
# any fitting method other than "FE" works for a random/mixed effects model
Q2.uni <-
rma.uni(
g ~ Trait.type:Gradient.category + Experiment + ID,
vi = dat_2$var.g,
data = dat_2,
method = "REML"
)
# get conditional residuals (residuals for each effect)
Q2res <- rstandard.rma.uni(Q2.uni, type = "conditional")
# create colour palette as  gradient of effect size g
nlvl <- length(dat_2$g)
pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))(nlvl)
pal <-pal[order(match(pal,dat_2$g))]
# plot funnel with all conditional residuals
metafor::funnel(Q2res$resid, sqrt(dat_2$var.g), level=c(90, 95, 99), shade=c("white", "gray55", "gray75"), col=pal, back = "white", refline=0, legend=TRUE, xlab = "Conditional residual", ylab = "Standard error")
# get standard errors of effect sizes
dat_1$sei <- sqrt(dat_1$var.g)
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + sei,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + var.g,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + var.g,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
Q1.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
summary(Q1.B)
forest.default(x= Q1.B$beta, sei =  Q1.B$se, ci.lb = Q1.B$ci.lb, ci.ub = Q1.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment invertebrate fecundity", "Environment invertebrate survivorship", "Pollution invertebrate fecundity", "Pollution invertebrate survivorship", "Resource invertebrate fecundity", "Resource invertebrate survivorship", "Environment vertebrate survivorship", "Pollution vertebrate survivorship", "Resource vertebrate survivorship"))
summary(Q1.B)
Q1.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
summary(Q1.B)
forest.default(x= Q1.B$beta, sei =  Q1.B$se, ci.lb = Q1.B$ci.lb, ci.ub = Q1.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment survivorship", "Pollution fecundity", "Pollution survivorship", "Resource fecundity", "Resource survivorship"))
Q1.B.R <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
Q1.B.R_est <- clubSandwich::coef_test(Q1.B.R, vcov = "CR2")
forest.default(x= Q1.B.R_est$beta, sei =  Q1.B.R_est$SE, ci.lb = (Q1.B.R_est$beta - 1.96 * Q1.B.R_est$SE) , ci.ub =(Q1.B.R_est$beta + 1.96 * Q1.B.R_est$SE),
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment survivorship", "Pollution fecundity", "Pollution survivorship", "Resource fecundity", "Resource survivorship"))
# get standard errors of effect sizes
dat_2$sei <- sqrt(dat_2$var.g)
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_2,
method = "REML")
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_2,
method = "REML")
Q2.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
summary(Q2.B)
forest.default(x= Q2.B$beta, sei =  Q2.B$se, ci.lb = Q2.B$ci.lb, ci.ub = Q2.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance", "Environment fecundity", "Environment intensity", "Environment prevalence", "Environment survivorship", "Pollution fecundity", "Pollution intensity", "Pollution prevalence", "Pollution survivorship", "Resource fecundity", "Resource intensity", "Resource prevalence", "Resource survivorship"))
Q2.B.R <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
Q2.B.R_est <- clubSandwich::coef_test(Q2.B.R, vcov = "CR2")
forest.default(x= Q2.B.R_est$beta, sei =  Q2.B.R_est$SE, ci.lb = (Q2.B.R_est$beta - 1.96 * Q2.B.R_est$SE) , ci.ub =(Q2.B.R_est$beta + 1.96 * Q2.B.R_est$SE),
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment intensity", "Environment prevalence", "Environment survivorship", "Pollution fecundity", "Pollution intensity", "Pollution prevalence", "Pollution survivorship", "Resource fecundity", "Resource intensity", "Resource prevalence", "Resource survivorship"))
# Cook's distance
Cook_dat1 <- cooks.distance(Q1, progbar=TRUE, dat_1$Study, reestimate=TRUE, parallel="multicore", ncpus = 2)
# how are these distances distributes?
hist(Cook_dat1)
# Which are the most influential studies?
Cook_dat1[which(Cook_dat1 > 1)]
# dfbetas
dfbetas_dat1 <- dfbetas.rma.mv(Q1, progbar=TRUE, dat_1$Study, reestimate=TRUE, parallel="multicore")
# Which are the most influential studies?
dfbetas_dat1[abs(dfbetas_dat1[,1])>1 | abs(dfbetas_dat1[,2])>1
| abs(dfbetas_dat1[,3])>1 | abs(dfbetas_dat1[,4])>1
| abs(dfbetas_dat1[,5])>1 | abs(dfbetas_dat1[,6])>1,]
# hat values
hat_dat1 <- hatvalues(Q1)
# Which are the most influential effects?
inf_cutoff <- 3 * length(Q1$beta)/nrow(dat_1)
dat_1$Study[hat_dat1 > inf_cutoff]
# Cook's distance
Cook_dat2 <- cooks.distance(Q2, progbar=TRUE, dat_2$Study, reestimate=TRUE, parallel="multicore", ncpus = 4)
# how are these distances distributes?
hist(Cook_dat2)
# Which are the most influential studies?
Cook_dat2[which(Cook_dat2 > 3)]
# dfbetas
dfbetas_dat2 <- dfbetas.rma.mv(Q2, progbar=TRUE, dat_2$Study, reestimate=TRUE, parallel="multicore")
# Which are the most influential studies?
dfbetas_dat2[abs(dfbetas_dat2[,1])>1 | abs(dfbetas_dat2[,2])>1
| abs(dfbetas_dat2[,3])>1 | abs(dfbetas_dat2[,4])>1
| abs(dfbetas_dat2[,5])>1 | abs(dfbetas_dat2[,6])>1,]
# hat values
hat_dat2 <- hatvalues(Q2)
# Which are the most influential effects?
inf_cutoff <- 3 * length(Q2$beta)/nrow(dat_2)
dat_2$Study[hat_dat2 > inf_cutoff]
#' @title Parametric simulation
#' @description Function for calculating I2 estimates using parametric simulations of model estimates taken from metafor. Note that the effectiveness of these simulations depends on the accuracy of model variance estimates.
#' @param estimate The estimate (i.e. variance) from a metafor model
#' @param sims The number of simulations
#' @param n The sample size used in estimating the variance
#' @author Daniel Noble - daniel.noble@anu.edu.au
#' @export
simMonteCarlo <- function(estimate, n, sims){
tmp <- data.frame(num = base::rep(1:sims, each = n),
y = stats::rnorm(n*sims, 0, base::sqrt(estimate)))
Var <- tmp %>% dplyr::group_by(num) %>% dplyr::summarise(Mean_var = stats::var(y))
return(as.numeric(Var$Mean_var))
}
## NOTE about PIPE: Run usethis::use_pipe() in the console. The package usethis will add what you need to import the pipe to your NAMESPACE and it will also drop warnings in checks
# Function for  rounding a data frame
round_df <- function(x, digits) {
numeric_columns <- sapply(x, class) == 'numeric'
x[numeric_columns] <-  round(x[numeric_columns], digits)
x
}
# Function for estimating I2
I2 <- function(model, v, ME = FALSE, sims = 1500, phylo = FALSE, obs = FALSE){
if(class(model) != "rma.mv" && class(model) != "rma"){
stop("The model object is not of class 'metafor'")
}
wi <- 1/v  #weight
Vw <- sum((wi) * (length(wi) - 1))  / (((sum(wi)^2) - sum((wi)^2)))
if("rma.mv" %in% class(model) | "rma" %in% class(model)){
# Monte Carlo Simulations
# From metafor extract the important statistics
sigma2 <- matrix(model$sigma2, nrow = 1, ncol = length(model$sigma2))
colnames(sigma2) <- model$s.names
sigmaN <- model$s.nlevels
if(obs == FALSE){
stop("Please add the name of the observation-level random effect, obs. If models do not include this, re-run models including (~1|obs) in the random effect list")
}
#For each variance estimate use Monte Carlo simulation of data
Sims <- data.frame(mapply(function(x,y) simMonteCarlo(x, y, sims = sims), x = sigma2, y = sigmaN))
colnames(Sims) <- colnames(sigma2)
#Calculate total variance
VT <- rowSums(cbind(Sims, Vw))
Vt <- rowSums(Sims)  # remove Vw
# For each variance component divide by the total variance. Note this needs to be fixed for phylo, but does deal with variable random effects.
I2_re <- Sims / VT
I2_total <- data.frame(Vt / VT)
tmpMatrix <- data.frame(I2_re[, -match("ID", colnames(I2_re))], total = I2_total)
names(tmpMatrix) = c(colnames(I2_re)[!colnames(I2_re) %in% 'ID'], 'total')
CI <- lapply(tmpMatrix, function(x) stats::quantile(x, c(0.025, 0.975), na.rm = TRUE))
I_CI <- as.data.frame(do.call(rbind, CI))
colnames(I_CI) <- c("2.5% CI", "97.5% CI")
I2_table <- cbind(I2_Est. = colMeans(tmpMatrix), I_CI )
class(I2_table) <- c("metaAidR", "data.frame")
return(round_df(I2_table, digits = 4))
}
}
I2.Q1 <- I2(Q1.B.R, v = dat_1$var.g, obs = "ID")*100
I2.Q1
# we account for covariance in sampling errors by using V, but assuming equal heterogeneity between fecundity vs survival and between environment, pollution and resources.
# matrix of sampling variances and covariances W
W <- solve(varcovmat_1_PD$mat)
# model matrix
X <- model.matrix(Q1.B)
# estimate heterogeneity
P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
# overall I2: how much of total variance is attributed to heterogeneity
100 * sum(Q1.B$sigma2) / (sum(Q1.B$sigma2) + (Q1.B$k-Q1.B$p)/sum(diag(P)))
# Heterogeneity within experiments, between experiments, between parasites
100 * Q1.B$sigma2 / (sum(Q1.B$sigma2) + (Q1.B$k-Q1$p)/sum(diag(P)))
sav <- confint(Q1.B)
# confidence intervals for I2
100 * sav[[1]]$random[1,2:3] /(sum(Q1.B$sigma2) + (Q1.B$k-Q1.B$p)/sum(diag(P))) ### CI for ID-level I^2
100 * sav[[2]]$random[1,2:3] / (sum(Q1.B$sigma2)+ (Q1.B$k-Q1.B$p)/sum(diag(P))) ### CI for the experiment-level I^2
#100 * sav[[3]]$random[1,2:3] / (sum(Q1$sigma2) + (Q1$k-Q1$p)/sum(diag(P)))  ### CI for the parasite-level I^2
I2.Q2 <- I2(Q2.B.R, v = dat_3$var.g, obs = "ID")*100
I2.Q2 <- I2(Q2.B.R, v = dat_2$var.g, obs = "ID")*100
I2.Q2
# we account for covariance in sampling errors by using V, but assuming equal heterogeneity between fecundity vs survival and between environment, pollution and resources.
# matrix of sampling variances and covariances W
W <- solve(varcovmat_2_PD$mat)
# model matrix
X <- model.matrix(Q2.B)
# estimate heterogeneity
P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
# overall I2: how much of total variance is attributed to heterogeneity
100 * sum(Q2.B$sigma2) / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))
# Heterogeneity between experiments, within experiments, between parasites
100 * Q2.B$sigma2 / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))
sav2 <- confint(Q2.B)
# confidence intervals for I2
100 * sav2[[1]]$random[1,2:3] /(sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P))) ### CI for ID-level I^2
100 * sav2[[2]]$random[1,2:3] / (sum(Q2.B$sigma2)+ (Q2.B$k-Q2.B$p)/sum(diag(P))) ### CI for the experiment-level I^2
#100 * sav2[[3]]$random[1,2:3] / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))  ### CI for the parasite-level I^2
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1m7.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
?orchad_plot
?orchard_plot
??orchard_plot
install.packages("orchaRd")
x <-
c(
"metafor", "kableExtra", "Matrix", "dplyr", "wesanderson", "weightr", "ggplot2", "MuMIn", "RColorBrewer", "tidyverse", "patchwork")
lapply(x, function(y) {
# check if installed, if not install
if (!y %in% installed.packages()[, "Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
install.packages("devtools")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
install.packages("R.rsp")
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
library(patchwork)
library(tidyverse)
library(metafor)
install.packages("devtools")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
library(orchaRd)
x <-
c(
"metafor", "kableExtra", "Matrix", "dplyr", "wesanderson", "weightr", "ggplot2", "MuMIn", "RColorBrewer", "tidyverse", "patchwork", "devtools", "R.rsp")
lapply(x, function(y) {
# check if installed, if not install
if (!y %in% installed.packages()[, "Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
scale_y_discrete( labels= c("Environment:Fecundity", "Pollution:Fecundity",  "Resource:Fecundity","Environment:Survival", "Pollution:Survival", "Resource:Survival"))
Q2.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
pal <- colorRampPalette(brewer.pal(11,"Spectral"))(length(Q2.1$beta))
orchard_plot(Q2.1, mod = "Gradient.category", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) +
scale_y_discrete( labels= c("Environment:Fecundity", "Pollution:Fecundity",  "Resource:Fecundity","Environment:Intensity", "Pollution:Intensity",  "Resource:Intensity","Environment:Prevalence", "Pollution:Prevalence", "Resource:Prevalence","Environment:Survival", "Pollution:Survival", "Resource:Survival"))
