pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))(nlvl)
pal <-pal[order(match(pal,dat_2$g))]
# plot funnel with all conditional residuals
metafor::funnel(Q2res$resid, sqrt(dat_2$var.g), level=c(90, 95, 99), shade=c("white", "gray55", "gray75"), col=pal, back = "white", refline=0, legend=TRUE, xlab = "Conditional residual", ylab = "Standard error")
# get standard errors of effect sizes
dat_1$sei <- sqrt(dat_1$var.g)
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + sei,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + var.g,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
rma.mv(g ~ 1 + var.g,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_1,
method = "REML")
Q1.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
summary(Q1.B)
forest.default(x= Q1.B$beta, sei =  Q1.B$se, ci.lb = Q1.B$ci.lb, ci.ub = Q1.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment invertebrate fecundity", "Environment invertebrate survivorship", "Pollution invertebrate fecundity", "Pollution invertebrate survivorship", "Resource invertebrate fecundity", "Resource invertebrate survivorship", "Environment vertebrate survivorship", "Pollution vertebrate survivorship", "Resource vertebrate survivorship"))
summary(Q1.B)
Q1.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_1_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
summary(Q1.B)
forest.default(x= Q1.B$beta, sei =  Q1.B$se, ci.lb = Q1.B$ci.lb, ci.ub = Q1.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment survivorship", "Pollution fecundity", "Pollution survivorship", "Resource fecundity", "Resource survivorship"))
Q1.B.R <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
Q1.B.R_est <- clubSandwich::coef_test(Q1.B.R, vcov = "CR2")
forest.default(x= Q1.B.R_est$beta, sei =  Q1.B.R_est$SE, ci.lb = (Q1.B.R_est$beta - 1.96 * Q1.B.R_est$SE) , ci.ub =(Q1.B.R_est$beta + 1.96 * Q1.B.R_est$SE),
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment survivorship", "Pollution fecundity", "Pollution survivorship", "Resource fecundity", "Resource survivorship"))
# get standard errors of effect sizes
dat_2$sei <- sqrt(dat_2$var.g)
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_2,
method = "REML")
# meta regression with SE
rma.mv(g ~ 1 + sei,
V = var.g,
random = list( ~ 1 | Experiment, ~ 1 | ID),
data = dat_2,
method = "REML")
Q2.B <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = varcovmat_2_PD$mat,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
summary(Q2.B)
forest.default(x= Q2.B$beta, sei =  Q2.B$se, ci.lb = Q2.B$ci.lb, ci.ub = Q2.B$ci.ub,
annotate=TRUE, showweights=T, header=F,
slab = c("variance", "Environment fecundity", "Environment intensity", "Environment prevalence", "Environment survivorship", "Pollution fecundity", "Pollution intensity", "Pollution prevalence", "Pollution survivorship", "Resource fecundity", "Resource intensity", "Resource prevalence", "Resource survivorship"))
Q2.B.R <-
rma.mv(
g ~ Trait.type:Gradient.category + var.g -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
Q2.B.R_est <- clubSandwich::coef_test(Q2.B.R, vcov = "CR2")
forest.default(x= Q2.B.R_est$beta, sei =  Q2.B.R_est$SE, ci.lb = (Q2.B.R_est$beta - 1.96 * Q2.B.R_est$SE) , ci.ub =(Q2.B.R_est$beta + 1.96 * Q2.B.R_est$SE),
annotate=TRUE, showweights=T, header=F,
slab = c("variance","Environment fecundity", "Environment intensity", "Environment prevalence", "Environment survivorship", "Pollution fecundity", "Pollution intensity", "Pollution prevalence", "Pollution survivorship", "Resource fecundity", "Resource intensity", "Resource prevalence", "Resource survivorship"))
# Cook's distance
Cook_dat1 <- cooks.distance(Q1, progbar=TRUE, dat_1$Study, reestimate=TRUE, parallel="multicore", ncpus = 2)
# how are these distances distributes?
hist(Cook_dat1)
# Which are the most influential studies?
Cook_dat1[which(Cook_dat1 > 1)]
# dfbetas
dfbetas_dat1 <- dfbetas.rma.mv(Q1, progbar=TRUE, dat_1$Study, reestimate=TRUE, parallel="multicore")
# Which are the most influential studies?
dfbetas_dat1[abs(dfbetas_dat1[,1])>1 | abs(dfbetas_dat1[,2])>1
| abs(dfbetas_dat1[,3])>1 | abs(dfbetas_dat1[,4])>1
| abs(dfbetas_dat1[,5])>1 | abs(dfbetas_dat1[,6])>1,]
# hat values
hat_dat1 <- hatvalues(Q1)
# Which are the most influential effects?
inf_cutoff <- 3 * length(Q1$beta)/nrow(dat_1)
dat_1$Study[hat_dat1 > inf_cutoff]
# Cook's distance
Cook_dat2 <- cooks.distance(Q2, progbar=TRUE, dat_2$Study, reestimate=TRUE, parallel="multicore", ncpus = 4)
# how are these distances distributes?
hist(Cook_dat2)
# Which are the most influential studies?
Cook_dat2[which(Cook_dat2 > 3)]
# dfbetas
dfbetas_dat2 <- dfbetas.rma.mv(Q2, progbar=TRUE, dat_2$Study, reestimate=TRUE, parallel="multicore")
# Which are the most influential studies?
dfbetas_dat2[abs(dfbetas_dat2[,1])>1 | abs(dfbetas_dat2[,2])>1
| abs(dfbetas_dat2[,3])>1 | abs(dfbetas_dat2[,4])>1
| abs(dfbetas_dat2[,5])>1 | abs(dfbetas_dat2[,6])>1,]
# hat values
hat_dat2 <- hatvalues(Q2)
# Which are the most influential effects?
inf_cutoff <- 3 * length(Q2$beta)/nrow(dat_2)
dat_2$Study[hat_dat2 > inf_cutoff]
#' @title Parametric simulation
#' @description Function for calculating I2 estimates using parametric simulations of model estimates taken from metafor. Note that the effectiveness of these simulations depends on the accuracy of model variance estimates.
#' @param estimate The estimate (i.e. variance) from a metafor model
#' @param sims The number of simulations
#' @param n The sample size used in estimating the variance
#' @author Daniel Noble - daniel.noble@anu.edu.au
#' @export
simMonteCarlo <- function(estimate, n, sims){
tmp <- data.frame(num = base::rep(1:sims, each = n),
y = stats::rnorm(n*sims, 0, base::sqrt(estimate)))
Var <- tmp %>% dplyr::group_by(num) %>% dplyr::summarise(Mean_var = stats::var(y))
return(as.numeric(Var$Mean_var))
}
## NOTE about PIPE: Run usethis::use_pipe() in the console. The package usethis will add what you need to import the pipe to your NAMESPACE and it will also drop warnings in checks
# Function for  rounding a data frame
round_df <- function(x, digits) {
numeric_columns <- sapply(x, class) == 'numeric'
x[numeric_columns] <-  round(x[numeric_columns], digits)
x
}
# Function for estimating I2
I2 <- function(model, v, ME = FALSE, sims = 1500, phylo = FALSE, obs = FALSE){
if(class(model) != "rma.mv" && class(model) != "rma"){
stop("The model object is not of class 'metafor'")
}
wi <- 1/v  #weight
Vw <- sum((wi) * (length(wi) - 1))  / (((sum(wi)^2) - sum((wi)^2)))
if("rma.mv" %in% class(model) | "rma" %in% class(model)){
# Monte Carlo Simulations
# From metafor extract the important statistics
sigma2 <- matrix(model$sigma2, nrow = 1, ncol = length(model$sigma2))
colnames(sigma2) <- model$s.names
sigmaN <- model$s.nlevels
if(obs == FALSE){
stop("Please add the name of the observation-level random effect, obs. If models do not include this, re-run models including (~1|obs) in the random effect list")
}
#For each variance estimate use Monte Carlo simulation of data
Sims <- data.frame(mapply(function(x,y) simMonteCarlo(x, y, sims = sims), x = sigma2, y = sigmaN))
colnames(Sims) <- colnames(sigma2)
#Calculate total variance
VT <- rowSums(cbind(Sims, Vw))
Vt <- rowSums(Sims)  # remove Vw
# For each variance component divide by the total variance. Note this needs to be fixed for phylo, but does deal with variable random effects.
I2_re <- Sims / VT
I2_total <- data.frame(Vt / VT)
tmpMatrix <- data.frame(I2_re[, -match("ID", colnames(I2_re))], total = I2_total)
names(tmpMatrix) = c(colnames(I2_re)[!colnames(I2_re) %in% 'ID'], 'total')
CI <- lapply(tmpMatrix, function(x) stats::quantile(x, c(0.025, 0.975), na.rm = TRUE))
I_CI <- as.data.frame(do.call(rbind, CI))
colnames(I_CI) <- c("2.5% CI", "97.5% CI")
I2_table <- cbind(I2_Est. = colMeans(tmpMatrix), I_CI )
class(I2_table) <- c("metaAidR", "data.frame")
return(round_df(I2_table, digits = 4))
}
}
I2.Q1 <- I2(Q1.B.R, v = dat_1$var.g, obs = "ID")*100
I2.Q1
# we account for covariance in sampling errors by using V, but assuming equal heterogeneity between fecundity vs survival and between environment, pollution and resources.
# matrix of sampling variances and covariances W
W <- solve(varcovmat_1_PD$mat)
# model matrix
X <- model.matrix(Q1.B)
# estimate heterogeneity
P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
# overall I2: how much of total variance is attributed to heterogeneity
100 * sum(Q1.B$sigma2) / (sum(Q1.B$sigma2) + (Q1.B$k-Q1.B$p)/sum(diag(P)))
# Heterogeneity within experiments, between experiments, between parasites
100 * Q1.B$sigma2 / (sum(Q1.B$sigma2) + (Q1.B$k-Q1$p)/sum(diag(P)))
sav <- confint(Q1.B)
# confidence intervals for I2
100 * sav[[1]]$random[1,2:3] /(sum(Q1.B$sigma2) + (Q1.B$k-Q1.B$p)/sum(diag(P))) ### CI for ID-level I^2
100 * sav[[2]]$random[1,2:3] / (sum(Q1.B$sigma2)+ (Q1.B$k-Q1.B$p)/sum(diag(P))) ### CI for the experiment-level I^2
#100 * sav[[3]]$random[1,2:3] / (sum(Q1$sigma2) + (Q1$k-Q1$p)/sum(diag(P)))  ### CI for the parasite-level I^2
I2.Q2 <- I2(Q2.B.R, v = dat_3$var.g, obs = "ID")*100
I2.Q2 <- I2(Q2.B.R, v = dat_2$var.g, obs = "ID")*100
I2.Q2
# we account for covariance in sampling errors by using V, but assuming equal heterogeneity between fecundity vs survival and between environment, pollution and resources.
# matrix of sampling variances and covariances W
W <- solve(varcovmat_2_PD$mat)
# model matrix
X <- model.matrix(Q2.B)
# estimate heterogeneity
P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
# overall I2: how much of total variance is attributed to heterogeneity
100 * sum(Q2.B$sigma2) / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))
# Heterogeneity between experiments, within experiments, between parasites
100 * Q2.B$sigma2 / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))
sav2 <- confint(Q2.B)
# confidence intervals for I2
100 * sav2[[1]]$random[1,2:3] /(sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P))) ### CI for ID-level I^2
100 * sav2[[2]]$random[1,2:3] / (sum(Q2.B$sigma2)+ (Q2.B$k-Q2.B$p)/sum(diag(P))) ### CI for the experiment-level I^2
#100 * sav2[[3]]$random[1,2:3] / (sum(Q2.B$sigma2) + (Q2.B$k-Q2.B$p)/sum(diag(P)))  ### CI for the parasite-level I^2
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1m7.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
?orchad_plot
?orchard_plot
??orchard_plot
install.packages("orchaRd")
x <-
c(
"metafor", "kableExtra", "Matrix", "dplyr", "wesanderson", "weightr", "ggplot2", "MuMIn", "RColorBrewer", "tidyverse", "patchwork")
lapply(x, function(y) {
# check if installed, if not install
if (!y %in% installed.packages()[, "Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
install.packages("devtools")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
install.packages("R.rsp")
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
library(patchwork)
library(tidyverse)
library(metafor)
install.packages("devtools")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
install.packages("tidyverse")
install.packages("metafor")
install.packages("patchwork")
library(orchaRd)
x <-
c(
"metafor", "kableExtra", "Matrix", "dplyr", "wesanderson", "weightr", "ggplot2", "MuMIn", "RColorBrewer", "tidyverse", "patchwork", "devtools", "R.rsp")
lapply(x, function(y) {
# check if installed, if not install
if (!y %in% installed.packages()[, "Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE)
library(orchaRd)
Q1.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_1,
method = "REML"
)
pal <- RColorBrewer::brewer.pal(6,"Spectral")
orchard_plot(Q1.1, mod = "var.g", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) #+
scale_y_discrete( labels= c("Environment:Fecundity", "Pollution:Fecundity",  "Resource:Fecundity","Environment:Survival", "Pollution:Survival", "Resource:Survival"))
Q2.1 <-
rma.mv(
g ~ Gradient.category:Trait.type -1,
V = var.g,
random = list( ~ 1 | ID, ~ 1 | Experiment),
data = dat_2,
method = "REML"
)
pal <- colorRampPalette(brewer.pal(11,"Spectral"))(length(Q2.1$beta))
orchard_plot(Q2.1, mod = "Gradient.category", xlab = "Standardised mean difference", transfm = "none", angle = 45, alpha = 0.7)+
scale_fill_manual(values = pal) + scale_colour_manual(values = pal) +
scale_y_discrete( labels= c("Environment:Fecundity", "Pollution:Fecundity",  "Resource:Fecundity","Environment:Intensity", "Pollution:Intensity",  "Resource:Intensity","Environment:Prevalence", "Pollution:Prevalence", "Resource:Prevalence","Environment:Survival", "Pollution:Survival", "Resource:Survival"))
knitr::opts_chunk$set(echo = TRUE)
rtools <- "C:\\Rtools\\bin"
gcc <- "C:\\Rtools\\gcc-4.6.3\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
# compile food gradient model from C definition
try(dyn.unload("C:/RData/food_gradient.dll")) # unload dll
system("R CMD SHLIB C:/RData/food_gradient.c")
dyn.load("C:/RData/food_gradient.dll") # Load dll
rtools <- "C:\\Rtools\\bin"
gcc <- "C:\\Rtools\\gcc-4.6.3\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
# compile food gradient model from C definition
try(dyn.unload("C:/RData/food_gradient.dll")) # unload dll
# compile food gradient model from C definition
try(dyn.unload("food_gradient.dll")) # unload dll
# compile food gradient model from C definition
try(dyn.unload("food_gradient.dll")) # unload dll
system("R CMD SHLIB food_gradient.c")
system("R CMD SHLIB C:/RData/food_gradient.c")
# compile food gradient model from C definition
try(dyn.unload("C:/RData/food_gradient.dll")) # unload dll
system("R CMD SHLIB /Users/amandavicente/OneDrive/Projects/HP-Meta-analysis/scripts/food_gradient.c")
system("food_gradient.c")
system("R CMD SHLIB C:/RData/food_gradient.c")
knitr::opts_chunk$set(echo = TRUE)
rtools <- "C:\\Rtools\\bin"
gcc <- "C:\\Rtools\\gcc-4.6.3\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
library(deSolve)
library(ggplot2)
Inits = c(S = 10, I = 1, R = 10)
pars = c(r = 1, K = 10, fM = 0.1, hr = 4, ht = 2, e = 0.5, rho = 0.25, BM = 0.01, d = 0.01, v = 0.04)
timespan = 100000
sim1 = lsoda(y = Inits, times=0:timespan, parms = pars, func="derivs", dllname = "food_gradient", initfunc="initmod",  maxsteps=1e6)
?rtools
??rtools
?Rccp
??Rccp
??Rcpp
```
sudo rm -rf /usr/local/gfortran /usr/local/bin/gfortran
sudo pkgutil --forget com.gnu.gfortran
```
knitr::opts_chunk$set(echo = TRUE)
# For Mac
# 1. Download Xcode from the App Store. Open the installed Xcode app, agree to the license, and let it install some "compoments"
# 2. Open the terminal, type "xcode-select --install" and follow the dialogs that open
# 3. Verify that the C compiler gcc is installed by opening the terminal and running the command clang. You should see an error that says “no input files”
# 4. Download and install the gfortran compiler .dmg from https://github.com/fxcoudert/gfortran-for-macOS/releases. Choose the latest version that is compatible with your operating system. Verify the installation by opening the terminal and running the command "gfortran". You should see an error that says “no input files”.
# 5. Go to https://www.xquartz.org/, download the .dmg and run the installer.
# 6. Verify that build tools are installed and available by opening an R console and running
install.packages("pkgbuild")
install.packages("pkgbuild")
pkgbuild::check_build_tools()
# 7. install Rcpp and RcppArmadillo
install.packages(c('Rcpp', 'RcppArmadillo'))
# 8. Compile the function using:
Rcpp::sourceCpp('env_gradient.cpp')
# 8. Compile the function using:
Rcpp::sourceCpp('env_gradient.cpp')
# compile food gradient model from C definition
try(dyn.unload("/food_gradient.dll")) # unload dll
system("R CMD SHLIB /food_gradient.c")
dyn.load("/food_gradient.dll") # Load dll
dyn.load("/food_gradient.dll") # Load dll
# compile food gradient model from C definition
try(dyn.unload("/food_gradient.dll")) # unload dll
# compile environmental gradient model from C definition
try(dyn.unload("C:/RData/env_gradient.dll")) # unload dll
system("R CMD SHLIB /food_gradient.c")
try(dyn.unload("food_gradient.so")) # unload so
try(dyn.unload("food_gradient.dso")) # unload so
try(dyn.unload("food_gradient.dylib")) # unload so
system("R CMD SHLIB /food_gradient.c")
try(dyn.unload("food_gradient.o")) # unload so
system("R CMD SHLIB /food_gradient.c")
?try
?dyn.unload
try(dyn.unload("food_gradient.so")) # unload dylib
try(dyn.unload("food_gradient.dyld")) # unload dylib
system("R CMD SHLIB /food_gradient.c")
try(dyn.unload("food_gradient.so")) # unload so
system("R CMD SHLIB /food_gradient.c")
dyn.load("food_gradient.so") # Load dll
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
rtools <- "C:\\Rtools\\bin"
gcc <- "C:\\Rtools\\gcc-4.6.3\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
try(dyn.unload("food_gradient.so")) # unload so
try(dyn.unload("food_gradient.dll")) # unload so
system("R CMD SHLIB /food_gradient.c")
dyn.load("food_gradient.so") # Load dll
system("echo $PATH")
try(dyn.unload("food_gradient.dylib")) # unload so
system("R CMD SHLIB /food_gradient.c")
dyn.load("food_gradient.dylib") # Load dll
system("echo $PATH")
unlink("~/.R/Makevars")
unlink("~/.Renviron")
rtools <- "C:\\Rtools\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
try(dyn.unload("food_gradient.dylib")) # unload so
try(dyn.unload("food_gradient.so")) # unload so
system("R CMD SHLIB /food_gradient.c")
# 1. Download Xcode from the App Store. Open the installed Xcode app, agree to the license, and let it install some "components"
# 2. Open the terminal, type "xcode-select --install" and follow the dialog that open
# 3. Verify that the C compiler gcc is installed by opening the terminal and running the command clang. You should see an error that says “no input files”
# 4. Download and install the gfortran compiler .dmg from https://github.com/fxcoudert/gfortran-for-macOS/releases. Choose the latest version that is compatible with your operating system. Verify the installation by opening the terminal and running the command "gfortran". You should see an error that says “no input files”.
# 5. Go to https://www.xquartz.org/, download the .dmg and run the installer.
# 6. Verify that build tools are installed and available by opening an R console and running
install.packages("pkgbuild")
install.packages("pkgbuild")
pkgbuild::check_build_tools()
install.packages("Rcmdr")
library(Rcmdr)
install.packages("Rcmdr")
install.packages("Rcmdr")
library(Rcmdr)
library(Rcmdr)
install.packages("Rcmdr")
library(Rcmdr)
library(Rcmdr)
knitr::opts_chunk$set(echo = TRUE)
rtools <- "C:\\Rtools\\bin"
gcc <- "C:\\Rtools\\gcc-4.6.3\\bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
# compile food gradient model from C definition
try(dyn.unload("food_gradient.so")) # unload so
system("R CMD SHLIB /food_gradient.c")
rtools <- "//Rtools//bin"
gcc <- "//Rtools//gcc-4.6.3//bin"
path <- strsplit(Sys.getenv("PATH"), ";")[[1]]
new_path <- c(rtools, gcc, path)
new_path <- new_path[!duplicated(tolower(new_path))]
Sys.setenv(PATH = paste(new_path, collapse = ";"))
# compile food gradient model from C definition
try(dyn.unload("food_gradient.so")) # unload so
# 1. Download Xcode from the App Store. Open the installed Xcode app, agree to the license, and let it install some "components"
# 2. Open the terminal, type "xcode-select --install" and follow the dialog that open
# 3. Verify that the C compiler gcc is installed by opening the terminal and running the command clang. You should see an error that says “no input files”
# 4. Download and install the gfortran compiler .dmg from https://github.com/fxcoudert/gfortran-for-macOS/releases. Choose the latest version that is compatible with your operating system. Verify the installation by opening the terminal and running the command "gfortran". You should see an error that says “no input files”.
# 5. Go to https://www.xquartz.org/, download the .dmg and run the installer.
# 6. Verify that build tools are installed and available by opening an R console and running
install.packages("pkgbuild")
install.packages("pkgbuild")
pkgbuild::check_build_tools()
pkgbuild::check_build_tools(debug = TRUE)
# 1. Download Xcode from the App Store. Open the installed Xcode app, agree to the license, and let it install some "components"
# 2. Open the terminal, type "xcode-select --install" and follow the dialog that open
# 3. Verify that the C compiler gcc is installed by opening the terminal and running the command clang. You should see an error that says “no input files”
# 4. Download and install the gfortran compiler .dmg from https://github.com/fxcoudert/gfortran-for-macOS/releases. Choose the latest version that is compatible with your operating system. Verify the installation by opening the terminal and running the command "gfortran". You should see an error that says “no input files”.
# 5. Go to https://www.xquartz.org/, download the .dmg and run the installer.
# 6. Verify that build tools are installed and available by opening an R console and running
install.packages("pkgbuild")
install.packages("pkgbuild")
install.packages("pkgbuild")
knitr::opts_chunk$set(echo = TRUE)
pkgbuild::check_build_tools()
# 7. install Rcpp and RcppArmadillo
install.packages(c('Rcpp', 'RcppArmadillo'))
install.packages(c("Rcpp", "RcppArmadillo"))
# 8. Compile the function using:
Rcpp::sourceCpp('env_gradient.cpp')
knitr::opts_chunk$set(echo = TRUE)
x <- c("deSolve", "ggplot2", "RColorBrewer")
lapply(x, function(y) {
# check if installed, if not install
if (!y %in% installed.packages()[, "Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
